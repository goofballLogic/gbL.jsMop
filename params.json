{"name":"Gbl.jsmop","body":"\r\n\r\n# gbL.jsMop\r\n\r\nSunday, 10 June 2010  \r\nVersion 0.9.3  \r\nN.B. Much of the code below has not been tested. For tested examples, see the tests and scenarios included. Feel free to contact me with abuse or questions.\r\n\r\n## Preamble\r\nThis is a library for message passing in javascript. The \"mop\" in jsMop is an acronym referring to OOP, but \"message-oriented\" instead of \"object-oriented\". A central \"mop\" object is used to send and receive messages (in place of a native message exchange construct).\r\n\r\nhttp://www.purl.org/stefan_ram/pub/doc_kay_oop_en\r\n\r\n## Environment\r\nDesigned to work specifically in the browser, or in Node, but should work in most CommonJS environments.\r\n\r\n## Running/Building tests\r\n####Without a browser (mocha)\r\nYou will need to\r\n\r\n    npm install mocha\r\n    npm install expect.js\r\n\r\nand then\r\n\r\n    make test\r\n\r\n####In the browser\r\nJust browse to \r\n\r\n    test-browser/browserTests.html\r\n\r\n####Building (and opening) the browser tests\r\nYou will need to\r\n\r\n    npm install browserify\r\n\r\nand then\r\n\r\n    make browser-test\r\n\r\n## Examples\r\nExample usage can be found in the /test/scenarios folder.\r\n\r\n### Basic usage\r\n\r\n####First step is to spin up a hub for the messages:\r\n\r\n    var mop = new gbL.jsMop.Mop();\r\n\r\nor\r\n\r\n    var mop = new require(\"gbL.jsMop\").Mop();\r\n\r\n####Sending\r\n\r\nThen, to send a message:\r\n\r\n    mop.send(\"Hello world\").as(\"test\");\r\n\r\nwhich sends a message with subject __*test*__ and payload of __*Hello world*__.\r\n\r\n####Receiving\r\nIf I am an object wanting to receive this sort of message, I would include a method named __receive_test__:\r\n\r\n    var receiver = {\r\n        receive_test: function(data) {\r\n            console.log(data);\r\n        }\r\n    };\r\n\r\nand I would register with the hub to receive messages:\r\n\r\n    mop.register(receiver, \"My first receiver\");\r\n\r\n#####_or_\r\n\r\nif I don't wish to register as an object, I can regsiter a call back function:\r\n\r\n    mop.registerHandler(\"test\", function(data) {\r\n        console.log(data);\r\n    });\r\n\r\n##Debugging\r\nThere are a few tools to help with debugging message passing. For analysis of registered objects and handlers, just send a census message:\r\n\r\n\tvar registered = mop.send().as(\"census\");\r\n\tconsole.log(\"Registered receivers: \" + registered.join(\", \");\r\n\t\r\nYou may also wish to turn on console logging by using:\r\n\r\n\tmop.debug = true;\r\n\t\r\nor\r\n\r\n\tmop.send.debug = true;\r\n\r\n##Bootstrapping modules\r\nSay you have a set of modules which contain objects wishing to participate in message exchange through a given mop. \r\n\r\nFor example, in Node, you might have a console-logger.js:\r\n\r\n\t(function(context) {\r\n\t\t\r\n\t\tvar mop;\r\n\t\t\r\n\t\tcontext.bootstrap = {\r\n\t\t\tinit: function(initMop) {\r\n\t\t\t\tmop = initMop;\r\n\t\t\t\tinitMop.Register(loggingSingleton, \"Console logger\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar loggingSingleton = new function() {\r\n\t\t\treturn {\r\n\t\t\t\treceive_log: function(data) {\r\n\t\t\t\t\tvar label = mop.topics.slice(1).join(\" \");\r\n\t\t\t\t\tconsole.log(label, data);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}();\r\n\t\t\r\n\t})(module.exports);\r\n\t\r\nand then as part of bootstrapping, include the console-logger:\r\n\r\n\tvar mop = new require(\"gbL.jsMop\").Mop();\r\n\tmop.boot({\r\n\t\t\"logger\": require(\"console-logger\"),\r\n\t\t\"worker\": require(\"important-worker-module\"),\r\n\t\t\"another\": require(\"another-important-worker-module\")\r\n\t});\r\n\r\nwhich will mean that e.g. the following will print my friend's name to the console:\r\n\r\n\tmop.send(\"Lisa Jue Bishop\").as(\"log the name of my dear friend\");\r\n\t\r\n#####Or\r\nIn the browser, you might have a ticker object:\r\n\r\n\t(function(context) {\r\n\t\tvar mop;\r\n\t\t\r\n\t\tcontext.Ticker = {\r\n\t\t\tbootstrap: {\r\n\t\t\t\tinit: function(jsMop) {\r\n\t\t\t\t\tmop = jsMop;\r\n\t\t\t\t\tmop.register(new Ticker(), \"Ticker\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tfunction Ticker() {\r\n\t\t\t// private state and behaviours\r\n\t\t\tvar cancelled = false;\r\n\t\t\tfunction tick() {\r\n\t\t\t\tmop.send().as(\"tick\");\r\n\t\t\t\tif(!cancelled) setTimeout(100, tick);\r\n\t\t\t}\r\n\t\t\t// message receivers\r\n\t\t\treturn {\r\n\t\t\t\treceive_cancel_ticker: function() {\r\n\t\t\t\t\tcancelled = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t})(gbL.Stocks || { gbL.Stocks = {} });\r\n\r\nwhich you could then boot as so:\r\n\r\n\tvar mop = new gbL.jsMop.Mop();\r\n\tmop.boot({\r\n\t\t\"ticker\": gbL.Stocks.Ticker,\r\n\t\t\"symbol-list\": gbL.Stocks.SymbolLister\r\n\t});\r\n\t\r\nwhich will cause <code>tick</code> messages to be sent until:\r\n\r\n\tmop.send().as(\"cancel ticker\");\r\n\t\r\nis sent.\r\n\t\r\n##Further patterns\r\n\r\n####Partial subject match\r\nIf you want to accept messages about a more general subject than those specified for the messages, you can receive messages which match the start of the subject:\r\n\r\n    function HelloListener() {\r\n    \tthis.receive_hello = function() {\r\n    \t\tconsole.log(mop.subject);\r\n    \t};\r\n    }\r\n\r\nwould receive:\r\n\r\n\tmop.send().as(\"hello world\");\r\n\t\r\nbut would also receive:\r\n\r\n\tmop.send().as(\"hello heaven\");\r\n\tmop.send().as(\"hello hell\");\r\n\r\n####Filtering messages\r\nIf you want to filter the messages received for a given subject, you can attaching a filtering function, like so:\r\n\r\n    function BeerWatcher() {\r\n    \tthis.receive_important_notification = function(notification) {\r\n    \t\tconsole.log(\"CRITICAL: \" + notification);\r\n    \t};\r\n    \tthis.receive_important_notification.filter = function(topics, data)\r\n    \t{\r\n    \t\t// only interested in notifications mentioning beer in their subject\r\n    \t\treturn ~topics.join(\" \").indexOf(\"beer\");\r\n    \t};\r\n    }\r\n\r\n####Filtering lots of handlers\r\nIf you have an object which only wants to receive messages which mention a specific ID, you can:\r\n\r\n\tfunction CalculationNode(nodeId, calculationStrategy) {\r\n\t\t// private state and behaviour\r\n\t\tvar parameters, lastResult;\r\n\t\tfunction reset(preserveResult) { \r\n\t\t\tparameters = [];\r\n\t\t\tpreserveResult || lastResult = null; \r\n\t\t}\r\n\t\tfunction execute() {\r\n\t\t\treturn (lastResult = calculationStrategy.apply(this, parameters));\r\n\t\t}\r\n\t\treset();\r\n\t\t\r\n\t\t// message receivers\r\n\t\tthis.receive_reset_parameters = function() {\r\n\t\t\treset(true);\r\n\t\t};\r\n\t\tthis.receive_parameterise = function() {\r\n\t\t\tfor(var i in arguments) parameters.push(arguments[i]);\r\n\t\t};\r\n\t\tthis.receive_calculate = function() {\r\n\t\t\tmop.send(execute()).as(\"result for node \" + nodeId);\r\n\t\t};\r\n\r\n\t\tmop.setReceiveFilters(this, function(topics, data) {\r\n\t\t\t// all the above, only for messages about this node (by Id)\r\n\t\t\treturn ~topics.indexOf(\"node \" + nodeId);\r\n\t\t});\r\n\t\t\r\n\t\t// unfiltered receivers\r\n\t\tthis.receive_global_reset = function() {\r\n\t\t\treset();\r\n\t\t};\r\n\t\tthis.receive_return_results = function() {\r\n\t\t\treturn new function() { this[nodeId] = lastResult; };\r\n\t\t}\r\n\t}\r\n\r\n####Adapter\r\nYou may wish to use an adapter to send and receive messages, especially when you want to mix the message-passing paradigm with calling methods directly. For example, using the revealing module pattern, you might do something like:\r\n\r\n    function ServiceAgent() {\r\n\r\n        var configuration = null;\r\n\t\tvar fetched = [];\r\n\t\t\r\n        function saveConfiguration(config) {\r\n            configuration = $(config).clone();\r\n        }\r\n        \r\n\t\tfunction dataGet(toGet) {\r\n\t\t\treturn mop\r\n\t\t\t\t.send(configuration.baseUrl, \"orders\")\r\n\t\t\t\t.as(\"ajax GET\");\r\n\t\t}\r\n\t\t\r\n\t\tfunction injestData(data) {\r\n\t\t\tfetched.push(data);\r\n\t\t}\r\n\t\t\r\n        // inner facet (mop adapter)\r\n        mop.register({\r\n        \treceive_configuration: saveConfiguration,\r\n        \treceive_data_received: injestData,\r\n        }, \"Service Agent\");\r\n        \r\n\t\t// outer facet (revealed methods)\r\n        return {\r\n            listOrders: function() {\r\n            \tvar data = null;\r\n            \tif(dataGet(\"orders\")) data = fetched.pop();\r\n            \treturn data;\r\n           \t}\r\n        };\r\n    }\r\n\r\nAn object constructed by this function will expect to collaborate with\r\n - An object whose responsibility is to broadcast configuration (sending messages with subject \"configuration\")\r\n - An object whose responsibility is to make AJAX calls (receiving subjects beginning with \"ajax\", and sending back the data with subject \"data received\")\r\n\r\nAnd it exposes a method which can be called directly as so:\r\n\r\n    var serviceAgent = new ServiceAgent();\r\n    var orders = serviceAgent.listOrders();\r\n    \r\n\r\n","tagline":"Message passing for javascript","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}